# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# =========================
# 0) Imports
# =========================
import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split
from sklearn.ensemble import AdaBoostRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

import matplotlib.pyplot as plt

# =========================
# 1) CSV yükle
# =========================
from google.colab import files
uploaded = files.upload()   # flights.csv yükle
csv_name = list(uploaded.keys())[0]

df = pd.read_csv(csv_name)
print("Raw shape:", df.shape)
print(df.columns.tolist())

# =========================
# 2) Gerekli kolon kontrolü + tip düzeltme
# =========================
REQUIRED = [
    "time", "flight",
    "position_x","position_y","position_z",
    "velocity_x","velocity_y","velocity_z",
    "angular_x","angular_y","angular_z",
    "linear_acceleration_x","linear_acceleration_y","linear_acceleration_z",
    "wind_speed","wind_angle",
    "battery_voltage","battery_current",
    "payload"
]

missing = [c for c in REQUIRED if c not in df.columns]
if missing:
    raise ValueError(f"Eksik kolon(lar): {missing}")

for c in REQUIRED:
    if c != "flight":
        df[c] = pd.to_numeric(df[c], errors="coerce")

df = df.dropna(subset=["time","flight","battery_voltage","battery_current"]).copy()
df = df.sort_values(["flight","time"]).reset_index(drop=True)

# =========================
# 3) Power hesapla + dt oluştur
# =========================
df["power_w"] = df["battery_voltage"] * df["battery_current"]
df["dt"] = df.groupby("flight")["time"].diff().fillna(0.0)

# Negatif dt temizle
df = df[df["dt"] >= 0].copy()

# Kayıt kopması için dt clamp (çok büyüğü kırp)
DT_MAX = 5.0
df.loc[df["dt"] > DT_MAX, "dt"] = DT_MAX

# =========================
# 4) Label: uçuş başına time-weighted average power
#    P_avg = sum(P*dt) / sum(dt)
# =========================
num = (df["power_w"] * df["dt"]).groupby(df["flight"]).sum().rename("P_num")
den = df["dt"].groupby(df["flight"]).sum().replace(0, np.nan).rename("P_den")
p_avg = (num / den).rename("P_avg_w")

flight_time = den.rename("flight_time_s")
label = pd.concat([p_avg, flight_time], axis=1).dropna(subset=["P_avg_w"]).copy()

print("Uçuş sayısı (label oluştu):", label.shape[0])

# =========================
# 5) Uçuş bazlı feature engineering
# =========================
COORD_MODE = "gps"  # "gps" (lon/lat varsayımı) veya "euclidean"

def haversine_m(lon1, lat1, lon2, lat2):
    R = 6371000.0
    phi1 = np.radians(lat1); phi2 = np.radians(lat2)
    dphi = np.radians(lat2 - lat1)
    dlambda = np.radians(lon2 - lon1)
    a = np.sin(dphi/2)**2 + np.cos(phi1)*np.cos(phi2)*np.sin(dlambda/2)**2
    return 2*R*np.arcsin(np.sqrt(a))

def build_flight_features(g: pd.DataFrame) -> dict:
    g = g.sort_values("time")
    out = {}

    T = float(g["dt"].sum())
    out["flight_time_s"] = T

    # speed magnitude
    v = np.sqrt(g["velocity_x"]**2 + g["velocity_y"]**2 + g["velocity_z"]**2)
    out["speed_mean"] = float(v.mean())
    out["speed_max"]  = float(v.max())
    out["speed_std"]  = float(v.std(ddof=0))

    # vertical dynamics
    out["vz_mean"] = float(g["velocity_z"].mean())
    out["vz_max"]  = float(g["velocity_z"].max())
    out["vz_min"]  = float(g["velocity_z"].min())

    # 3D distance from positions
    x = g["position_x"].to_numpy()
    y = g["position_y"].to_numpy()
    z = g["position_z"].to_numpy()

    if len(x) < 2:
        out["dist3d_total"] = 0.0
    else:
        if COORD_MODE == "gps":
            horiz = haversine_m(x[:-1], y[:-1], x[1:], y[1:])
            dz = (z[1:] - z[:-1])
            seg = np.sqrt(horiz**2 + dz**2)
            out["dist3d_total"] = float(np.nansum(seg))
        else:
            dx = np.diff(x); dy = np.diff(y); dz = np.diff(z)
            out["dist3d_total"] = float(np.nansum(np.sqrt(dx*dx + dy*dy + dz*dz)))

    # altitude stats (using position_z)
    out["z_delta"] = float(z[-1] - z[0]) if len(z) > 1 else 0.0
    out["z_max"]   = float(np.nanmax(z))
    out["z_min"]   = float(np.nanmin(z))
    out["z_std"]   = float(np.nanstd(z))

    # maneuver: angular magnitude
    omega = np.sqrt(g["angular_x"]**2 + g["angular_y"]**2 + g["angular_z"]**2)
    out["omega_mean"] = float(omega.mean())
    out["omega_max"]  = float(omega.max())
    out["omega_std"]  = float(omega.std(ddof=0))

    # linear accel magnitude
    acc = np.sqrt(g["linear_acceleration_x"]**2 + g["linear_acceleration_y"]**2 + g["linear_acceleration_z"]**2)
    out["acc_mean"] = float(acc.mean())
    out["acc_max"]  = float(acc.max())
    out["acc_std"]  = float(acc.std(ddof=0))

    # wind stats
    w = g["wind_speed"]
    out["wind_mean"] = float(w.mean())
    out["wind_max"]  = float(w.max())
    out["wind_std"]  = float(w.std(ddof=0))

    # head/crosswind proxy (same ref frame varsayımı)
    heading = np.arctan2(g["velocity_y"].to_numpy(), g["velocity_x"].to_numpy())
    wind_angle = g["wind_angle"].to_numpy()
    wind_speed = g["wind_speed"].to_numpy()

    head = wind_speed * np.cos(wind_angle - heading)
    cross = wind_speed * np.sin(wind_angle - heading)

    out["headwind_mean"] = float(np.nanmean(head))
    out["crosswind_mean"] = float(np.nanmean(cross))
    out["headwind_std"] = float(np.nanstd(head))
    out["crosswind_std"] = float(np.nanstd(cross))

    # payload
    out["payload"] = float(np.nanmedian(g["payload"].to_numpy()))

    return out

rows = []
for fid, g in df.groupby("flight"):
    if fid not in label.index:
        continue
    feats = build_flight_features(g)
    feats["flight"] = fid
    rows.append(feats)

feat_df = pd.DataFrame(rows).set_index("flight")
data = feat_df.join(label[["P_avg_w"]], how="inner").dropna()

print("Flight-level dataset:", data.shape)

# =========================
# 6) AdaBoost train
# =========================
X = data.drop(columns=["P_avg_w"])
y = data["P_avg_w"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

base = DecisionTreeRegressor(max_depth=4, random_state=42)
model = AdaBoostRegressor(
    estimator=base,
    n_estimators=300,
    learning_rate=0.05,
    random_state=42
)

model.fit(X_train, y_train)
pred = model.predict(X_test)

mae = mean_absolute_error(y_test, pred)
rmse = np.sqrt(mean_squared_error(y_test, pred))
r2 = r2_score(y_test, pred)

print(f"MAE  (W): {mae:.3f}")
print(f"RMSE (W): {rmse:.3f}")
print(f"R^2      : {r2:.3f}")

plt.figure()
plt.scatter(y_test, pred)
plt.xlabel("Gerçek Ortalama Güç (W)")
plt.ylabel("Tahmin Ortalama Güç (W)")
plt.title("Actual vs Predicted (Power)")
plt.show()

# Feature importance (AdaBoost weighted average over trees)
importances = np.zeros(X.shape[1], dtype=float)
weights = model.estimator_weights_
for est, w in zip(model.estimators_, weights):
    if hasattr(est, "feature_importances_"):
        importances += w * est.feature_importances_
importances /= (weights.sum() + 1e-12)

imp = pd.Series(importances, index=X.columns).sort_values(ascending=False)
print("\nTop 12 importance:")
print(imp.head(12))

plt.figure()
imp.head(12).sort_values().plot(kind="barh")
plt.xlabel("Importance (relative)")
plt.title("Top Feature Importances (Power)")
plt.show()
print('\n')

# =========================
# Scatter + Doğrusal Referanslar
# =========================
import numpy as np
import matplotlib.pyplot as plt

# Güvenli numpy dönüşümü
y_true = np.array(y_test)
y_pred = np.array(pred)

plt.figure(figsize=(6,6))
plt.scatter(y_true, y_pred, alpha=0.7, label="Tahminler")

# 1) y = x → ideal tahmin referansı
min_val = min(y_true.min(), y_pred.min())
max_val = max(y_true.max(), y_pred.max())
plt.plot([min_val, max_val],
         [min_val, max_val],
         'k--', linewidth=2, label="İdeal (y = x)")

# 2) En küçük kareler doğrusal regresyon (bias analizi)
coef = np.polyfit(y_true, y_pred, 1)   # y_pred ≈ a*y_true + b
poly = np.poly1d(coef)
x_line = np.linspace(min_val, max_val, 100)
plt.plot(x_line, poly(x_line),
         'r-', linewidth=2,
         label=f"Doğrusal fit: y = {coef[0]:.2f}x + {coef[1]:.2f}")

plt.xlabel("Gerçek Ortalama Güç (W)")
plt.ylabel("Tahmin Ortalama Güç (W)")
plt.title("Actual vs Predicted (Power) – Doğrusal Analiz")
plt.legend()
plt.grid(True)
plt.show()

print(f"Doğrusal fit katsayıları → eğim (slope): {coef[0]:.3f}, kesişim (intercept): {coef[1]:.3f}")

# ============================================================
# 7) OPTIMIZATION (Genetic Algorithm) - Power-only
# ============================================================
# Amaç: Başlangıç -> hedef arasında, ara waypoint'leri seçerek
#      modelin tahmin ettiği P_avg'i minimize etmek.
#
# Not: Bu optimizasyon, "flight-level" modelle tutarlıdır:
# rota adayını bir uçuş olarak temsil eder, feature çıkarır,
# modelden P_avg tahmini alır, GA bunu minimize eder.

# ---- Basit senaryo tanımı ----
# Start/Goal: veri içinden gerçekçi bir uçuşun başlangıç/bitisini kullanabiliriz.
# Örnek olarak rastgele bir flight seçelim:
sample_flight = data.index[0]
g0 = df[df["flight"] == sample_flight].sort_values("time")

start = np.array([g0["position_x"].iloc[0], g0["position_y"].iloc[0], g0["position_z"].iloc[0]], dtype=float)
goal  = np.array([g0["position_x"].iloc[-1], g0["position_y"].iloc[-1], g0["position_z"].iloc[-1]], dtype=float)

# Çevre koşulları ve görev parametreleri (power-only model için input olacak)
PAYLOAD_FIXED = float(np.nanmedian(g0["payload"]))
WIND_MEAN = float(np.nanmean(g0["wind_speed"]))
WIND_STD  = float(np.nanstd(g0["wind_speed"]))
HEADW_MEAN = float(0.0)   # basitleştirme: 0 koyabiliriz; istersen heading ile hesaplatırız
CROSSW_MEAN = float(0.0)

# Speed ve manevra proxy'leri: rota üzerinden yaklaşık üretilecek
CRUISE_SPEED = float(np.nanmean(np.sqrt(g0["velocity_x"]**2 + g0["velocity_y"]**2 + g0["velocity_z"]**2)))
if not np.isfinite(CRUISE_SPEED) or CRUISE_SPEED <= 0:
    CRUISE_SPEED = 12.0  # fallback

# =========================
# 7.1 Parametrik rota: K ara waypoint (3B)
# Genom: [wx1, wy1, wz1, wx2, wy2, wz2, ...]
# =========================
K = 3  # ara waypoint sayısı (3 güzel)

def path_points(genome):
    pts = [start]
    for i in range(K):
        pts.append(np.array(genome[3*i:3*i+3], dtype=float))
    pts.append(goal)
    return np.vstack(pts)

def path_dist_3d(pts):
    # 3B Öklid dist: (gps modunda lon/lat ise burada approx; optimization için yeter)
    d = np.linalg.norm(np.diff(pts, axis=0), axis=1)
    return float(np.sum(d))

def path_turn_proxy(pts):
    # basit turn proxy: ardışık segmentlerin açı değişimi toplamı
    # v1·v2 ile açı
    total = 0.0
    for i in range(1, len(pts)-1):
        a = pts[i] - pts[i-1]
        b = pts[i+1] - pts[i]
        na = np.linalg.norm(a); nb = np.linalg.norm(b)
        if na < 1e-9 or nb < 1e-9:
            continue
        cosang = np.clip(np.dot(a,b)/(na*nb), -1, 1)
        ang = np.arccos(cosang)
        total += ang
    return float(total)

def build_candidate_features(genome):
    pts = path_points(genome)

    dist = path_dist_3d(pts)

    # uçuş süresi approx: T = dist / v
    T = dist / max(CRUISE_SPEED, 1e-6)

    # z istatistikleri
    z = pts[:,2]
    z_delta = float(z[-1] - z[0])
    z_max = float(np.max(z))
    z_min = float(np.min(z))
    z_std = float(np.std(z))

    # dikey hız proxy: dz / T
    vz_mean = z_delta / max(T, 1e-6)
    # max/min proxy: segment başına dz/dt
    seg = np.diff(pts, axis=0)
    seg_len = np.linalg.norm(seg, axis=1) + 1e-9
    seg_time = seg_len / max(CRUISE_SPEED, 1e-6)
    vz_seg = seg[:,2] / np.maximum(seg_time, 1e-6)
    vz_max = float(np.max(vz_seg))
    vz_min = float(np.min(vz_seg))

    # manevra proxy: turn amount -> omega proxy
    turn = path_turn_proxy(pts)
    omega_mean = turn / max(T, 1e-6)
    omega_max = omega_mean * 1.5
    omega_std = omega_mean * 0.3

    # ivme proxy: turn yoğunluğundan
    acc_mean = abs(omega_mean) * max(CRUISE_SPEED, 1e-6)
    acc_max = acc_mean * 1.8
    acc_std = acc_mean * 0.4

    # speed stats (constant cruise)
    speed_mean = CRUISE_SPEED
    speed_max = CRUISE_SPEED
    speed_std = 0.0

    # wind features (fixed)
    wind_mean = WIND_MEAN
    wind_max = WIND_MEAN + 2*WIND_STD
    wind_std = WIND_STD

    # head/cross - burada sabit tuttuk (istersen heading hesaplatırız)
    headwind_mean = HEADW_MEAN
    crosswind_mean = CROSSW_MEAN
    headwind_std = 0.0
    crosswind_std = 0.0

    payload = PAYLOAD_FIXED

    # Modelin beklediği kolonlara birebir dictionary
    feats = {
        "flight_time_s": T,
        "speed_mean": speed_mean,
        "speed_max": speed_max,
        "speed_std": speed_std,
        "vz_mean": vz_mean,
        "vz_max": vz_max,
        "vz_min": vz_min,
        "dist3d_total": dist,
        "z_delta": z_delta,
        "z_max": z_max,
        "z_min": z_min,
        "z_std": z_std,
        "omega_mean": omega_mean,
        "omega_max": omega_max,
        "omega_std": omega_std,
        "acc_mean": acc_mean,
        "acc_max": acc_max,
        "acc_std": acc_std,
        "wind_mean": wind_mean,
        "wind_max": wind_max,
        "wind_std": wind_std,
        "headwind_mean": headwind_mean,
        "crosswind_mean": crosswind_mean,
        "headwind_std": headwind_std,
        "crosswind_std": crosswind_std,
        "payload": payload
    }
    return feats

def predict_power_for_genome(genome):
    feats = build_candidate_features(genome)
    # X kolon sırası ile dataframe
    Xc = pd.DataFrame([feats])[X.columns]
    return float(model.predict(Xc)[0])

# =========================
# 7.2 Genetic Algorithm
# =========================
rng = np.random.default_rng(42)

# Search bounds: start-goal box etrafında ara waypoint'ler
# Lon/lat ise bu "derece" ölçeği; gene de optimizasyon için iş görür.
mins = np.minimum(start, goal)
maxs = np.maximum(start, goal)

# biraz genişlet
pad_xy = 0.01   # gps ise ~1km mertebesi (yaklaşık), euclidean ise 0.01 m gibi olur; gerektiğinde ayarla
pad_z  = 20.0

lower = np.array([mins[0]-pad_xy, mins[1]-pad_xy, mins[2]-pad_z] * K, dtype=float)
upper = np.array([maxs[0]+pad_xy, maxs[1]+pad_xy, maxs[2]+pad_z] * K, dtype=float)

def init_population(pop_size):
    return rng.uniform(lower, upper, size=(pop_size, 3*K))

def tournament_select(pop, scores, k=3):
    idx = rng.integers(0, len(pop), size=k)
    best = idx[np.argmin(scores[idx])]
    return pop[best].copy()

def crossover(a, b, p=0.7):
    if rng.random() > p:
        return a.copy(), b.copy()
    mask = rng.random(a.shape) < 0.5
    c1 = np.where(mask, a, b)
    c2 = np.where(mask, b, a)
    return c1, c2

def mutate(x, rate=0.15, scale=0.15):
    # scale: bound aralığının bir oranı kadar gaussian
    span = (upper - lower)
    for i in range(len(x)):
        if rng.random() < rate:
            x[i] += rng.normal(0, scale*span[i])
    return np.clip(x, lower, upper)

def evaluate(pop):
    return np.array([predict_power_for_genome(ind) for ind in pop], dtype=float)

POP = 40
GEN = 30
ELITE = 4

pop = init_population(POP)
scores = evaluate(pop)

best_idx = int(np.argmin(scores))
best_genome = pop[best_idx].copy()
best_score = float(scores[best_idx])

print("\nGA start best P_avg(W):", best_score)

for g in range(GEN):
    # elitizm
    elite_idx = np.argsort(scores)[:ELITE]
    new_pop = [pop[i].copy() for i in elite_idx]

    while len(new_pop) < POP:
        p1 = tournament_select(pop, scores, k=3)
        p2 = tournament_select(pop, scores, k=3)
        c1, c2 = crossover(p1, p2, p=0.8)
        c1 = mutate(c1, rate=0.20, scale=0.10)
        c2 = mutate(c2, rate=0.20, scale=0.10)
        new_pop.append(c1)
        if len(new_pop) < POP:
            new_pop.append(c2)

    pop = np.array(new_pop)
    scores = evaluate(pop)

    gen_best = float(np.min(scores))
    if gen_best < best_score:
        best_score = gen_best
        best_genome = pop[int(np.argmin(scores))].copy()

    if (g+1) % 5 == 0:
        print(f"Gen {g+1:02d} | best P_avg(W): {best_score:.3f}")

print("\nGA final best P_avg(W):", best_score)

# =========================
# 7.3 Sonuç rotayı çiz (3B)
# =========================
best_pts = path_points(best_genome)

plt.figure()
plt.plot(best_pts[:,0], best_pts[:,1], marker="o")
plt.title("Optimized Path (XY projection)")
plt.xlabel("x (lon or local x)")
plt.ylabel("y (lat or local y)")
plt.show()

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(best_pts[:,0], best_pts[:,1], best_pts[:,2], marker="o")
ax.set_title("Optimized Path (3D)")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("z")
plt.show()

print("\nStart:", start)
print("Goal :", goal)
print("Waypoints:\n", best_pts[1:-1])
print("Predicted P_avg(W):", best_score)

# ============================================================
# 8) SCENARIO: 3D ENGELLER (BİNA) + YEREL RÜZGAR ALANI
# ============================================================

import numpy as np
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# 8.0) Senaryo sabitleri (akademik olarak tanımlı)
# ------------------------------------------------------------
CRUISE_SPEED = 12.0   # m/s
WIND_MEAN    = 4.0    # m/s
PAYLOAD_FIXED = 1.5  # kg (örnek payload)

# ------------------------------------------------------------
# 8.1) Start / Goal (sentetik ama fiziksel olarak mantıklı)
# ------------------------------------------------------------
start = np.array([0.0,   0.0,  40.0])   # (x,y,z) metre
goal  = np.array([1000.0, 800.0, 40.0])

print("Start:", start)
print("Goal :", goal)

# ------------------------------------------------------------
# 8.2) Grid tanımı
# ------------------------------------------------------------
DX = 20.0
DZ = 10.0

pad_xy = 200.0
pad_z  = 40.0

X_MIN, X_MAX = -pad_xy, 1000.0 + pad_xy
Y_MIN, Y_MAX = -pad_xy,  800.0 + pad_xy
Z_MIN, Z_MAX = 0.0, 100.0

NX = int((X_MAX - X_MIN) / DX) + 1
NY = int((Y_MAX - Y_MIN) / DX) + 1
NZ = int((Z_MAX - Z_MIN) / DZ) + 1

print("Grid size:", NX, NY, NZ)

# ------------------------------------------------------------
# 8.3) Grid dönüşümleri
# ------------------------------------------------------------
def xyz_to_idx(p):
    return (
        int(round((p[0] - X_MIN) / DX)),
        int(round((p[1] - Y_MIN) / DX)),
        int(round((p[2] - Z_MIN) / DZ))
    )

def idx_to_xyz(idx):
    return np.array([
        X_MIN + idx[0] * DX,
        Y_MIN + idx[1] * DX,
        Z_MIN + idx[2] * DZ
    ], dtype=float)

def in_bounds(idx):
    ix, iy, iz = idx
    return (0 <= ix < NX) and (0 <= iy < NY) and (0 <= iz < NZ)

# ------------------------------------------------------------
# 8.4) Binalar (3B engeller)
# ------------------------------------------------------------
buildings = [
    (350, 500, 200, 400, 0, 70),
    (650, 820, 450, 650, 0, 60),
]

def point_in_box(x, y, z, box):
    xmin, xmax, ymin, ymax, zmin, zmax = box
    return xmin <= x <= xmax and ymin <= y <= ymax and zmin <= z <= zmax

def is_occupied(idx):
    p = idx_to_xyz(idx)
    for b in buildings:
        if point_in_box(p[0], p[1], p[2], b):
            return True
    return False

# ------------------------------------------------------------
# 8.5) Yerel rüzgâr alanı (bina etkili)
# ------------------------------------------------------------
W0 = np.array([WIND_MEAN, 0.0, 0.0])

def box_center(b):
    return np.array([(b[0]+b[1])/2, (b[2]+b[3])/2, (b[4]+b[5])/2])

def wind_at(p):
    w = W0.copy()
    for b in buildings:
        c = box_center(b)
        d = np.linalg.norm(p - c)
        sigma = 150.0
        A = 5.0
        alpha = A * np.exp(-(d**2)/(2*sigma**2))

        radial = (p - c)
        radial /= (np.linalg.norm(radial) + 1e-9)
        side = np.array([-radial[1], radial[0], 0.0])

        w += alpha * (0.3 * radial + 0.7 * side)
    return w

# ============================================================
# 9A) A*: Proxy cost (NO AdaBoost in the loop)
# ============================================================

import heapq
import numpy as np
import matplotlib.pyplot as plt

V_REF = float(CRUISE_SPEED) if ("CRUISE_SPEED" in globals() and np.isfinite(CRUISE_SPEED) and CRUISE_SPEED > 0) else 12.0

start_idx = xyz_to_idx(start)
goal_idx  = xyz_to_idx(goal)

print("Start idx:", start_idx, "| occupied?", is_occupied(start_idx))
print("Goal  idx:", goal_idx,  "| occupied?", is_occupied(goal_idx))

# 6-connected (en hızlı)
NEIGHBORS = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)]

def heuristic_dist(idx):
    p = idx_to_xyz(idx)
    g = idx_to_xyz(goal_idx)
    return float(np.linalg.norm(g - p)) / max(V_REF, 1e-6)

def proxy_edge_cost(u_idx, v_idx, prev_heading_xy=None):
    pu = idx_to_xyz(u_idx)
    pv = idx_to_xyz(v_idx)

    d = float(np.linalg.norm(pv - pu))
    dt = d / max(V_REF, 1e-6)

    # heading
    dxy = pv[:2] - pu[:2]
    n = float(np.linalg.norm(dxy))
    heading_xy = np.array([1.0,0.0]) if n < 1e-9 else dxy / n

    # turn proxy
    turn = 0.0
    if prev_heading_xy is not None:
        prev = np.array(prev_heading_xy, dtype=float)
        prev = prev / (np.linalg.norm(prev)+1e-12)
        turn = float(np.arccos(np.clip(np.dot(prev, heading_xy), -1, 1)))

    # wind proxy: crosswind/overall wind cezalandır
    w = wind_at((pu+pv)/2.0)
    wind_xy = float(np.linalg.norm(w[:2]))

    # proxy cost: dt * (base + wind + turn)
    cost = dt * (1.0 + 0.10*wind_xy + 0.20*turn)

    return cost, heading_xy

def astar_proxy(start_idx, goal_idx, max_expansions=200000):
    open_heap = []
    heapq.heappush(open_heap, (heuristic_dist(start_idx), 0.0, start_idx, None, None))
    came_from = {}
    gscore = {start_idx: 0.0}
    visited = set()
    exp = 0

    while open_heap:
        f, gcur, cur, parent, prev_heading = heapq.heappop(open_heap)

        if cur in visited:
            continue
        visited.add(cur)
        came_from[cur] = (parent, prev_heading)

        if cur == goal_idx:
            break

        exp += 1
        if exp >= max_expansions:
            print("Proxy A*: max expansions -> early stop")
            break

        for dd in NEIGHBORS:
            nb = (cur[0]+dd[0], cur[1]+dd[1], cur[2]+dd[2])
            if not in_bounds(nb):
                continue
            if is_occupied(nb):
                continue

            step_cost, new_heading = proxy_edge_cost(cur, nb, prev_heading)
            tentative = gcur + step_cost

            if nb not in gscore or tentative < gscore[nb]:
                gscore[nb] = tentative
                heapq.heappush(open_heap, (tentative + heuristic_dist(nb), tentative, nb, cur, new_heading))

    if goal_idx not in came_from:
        return None

    path = []
    node = goal_idx
    while node is not None:
        path.append(node)
        node = came_from.get(node, (None,None))[0]
    path.reverse()
    return path

# ---- RUN ----
path_idx = astar_proxy(start_idx, goal_idx)

if path_idx is None:
    print("Proxy A* path bulunamadı.")
else:
    path_xyz = np.vstack([idx_to_xyz(i) for i in path_idx])
    print("Proxy A* path node count:", len(path_idx))

    # ---- 2D (XY) ----
    plt.figure(figsize=(7,6))
    plt.plot(path_xyz[:,0], path_xyz[:,1], marker="o", markersize=2, label="Proxy A* Path")
    for b in buildings:
        xmin, xmax, ymin, ymax, zmin, zmax = b
        plt.fill([xmin,xmax,xmax,xmin,xmin],[ymin,ymin,ymax,ymax,ymin], alpha=0.3)
    plt.scatter([start[0]],[start[1]], s=80, label="Start")
    plt.scatter([goal[0]],[goal[1]], s=80, label="Goal")
    plt.title("Proxy A* Path (XY)")
    plt.xlabel("x"); plt.ylabel("y")
    plt.legend(); plt.grid(True)
    plt.show()

    # ---- 3D ----
    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(111, projection="3d")
    ax.plot(path_xyz[:,0], path_xyz[:,1], path_xyz[:,2], marker="o", markersize=2, label="Proxy A* Path")

    # buildings top faces
    for b in buildings:
        xmin, xmax, ymin, ymax, zmin, zmax = b
        xs = [xmin, xmax, xmax, xmin, xmin]
        ys = [ymin, ymin, ymax, ymax, ymin]
        zs = [zmax]*5
        ax.plot(xs, ys, zs)

    ax.scatter([start[0]], [start[1]], [start[2]], s=60, label="Start")
    ax.scatter([goal[0]],  [goal[1]],  [goal[2]],  s=60, label="Goal")

    ax.set_title("Proxy A* Path (3D)")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    ax.legend()
    plt.show()

# ============================================================
# 9B) Evaluate Proxy-A* Path with AdaBoost + Power & Cost Plots
# ============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Ön koşullar ---
if path_idx is None:
    raise ValueError("Önce 9A (Proxy A*) çalıştır, path_idx oluşsun.")
if "model" not in globals():
    raise ValueError("AdaBoost modeli bulunamadı. Önce modeli eğit (part 6).")

# model feature isimleri
if hasattr(model, "feature_names_in_"):
    FEATURES = list(model.feature_names_in_)
else:
    raise ValueError("Model feature names not found. AdaBoost model trained mi?")

V_REF = float(CRUISE_SPEED) if ("CRUISE_SPEED" in globals() and np.isfinite(CRUISE_SPEED) and CRUISE_SPEED > 0) else 12.0

def make_X_edge(feats):
    row = {c: 0.0 for c in FEATURES}
    for k, v in feats.items():
        if k in row:
            row[k] = float(v)
    return pd.DataFrame([row], columns=FEATURES)

def head_cross_from_wind(heading_xy_unit, w_vec):
    w_xy = np.array([w_vec[0], w_vec[1]], dtype=float)
    head = float(np.dot(w_xy, heading_xy_unit))
    cross = float(np.linalg.norm(w_xy - head * heading_xy_unit))
    return head, cross

def segment_power_cost(pu, pv, prev_heading=None):
    d = float(np.linalg.norm(pv - pu))
    dt = d / max(V_REF, 1e-6)

    dxy = pv[:2] - pu[:2]
    n = float(np.linalg.norm(dxy))
    heading_xy = np.array([1.0,0.0]) if n < 1e-9 else dxy / n

    turn = 0.0
    if prev_heading is not None:
        prev = prev_heading / (np.linalg.norm(prev_heading)+1e-12)
        turn = float(np.arccos(np.clip(np.dot(prev, heading_xy), -1, 1)))

    wvec = wind_at((pu+pv)/2.0)
    head, cross = head_cross_from_wind(heading_xy, wvec)

    dh = float(pv[2] - pu[2])
    vz = dh / max(dt, 1e-6)

    omega_mean = turn / max(dt, 1e-6)
    acc_mean = abs(omega_mean) * max(V_REF, 1e-6)
    wind_speed_local = float(np.linalg.norm(wvec[:2]))

    feats = {
        "flight_time_s": dt,
        "speed_mean": V_REF,
        "speed_max": V_REF,
        "speed_std": 0.0,
        "vz_mean": vz,
        "vz_max": abs(vz),
        "vz_min": -abs(vz),
        "dist3d_total": d,
        "z_delta": dh,
        "z_max": float(pv[2]),
        "z_min": float(pu[2]),
        "z_std": float(np.std([pu[2], pv[2]])),
        "omega_mean": omega_mean,
        "omega_max": abs(omega_mean),
        "omega_std": abs(omega_mean)*0.3,
        "acc_mean": acc_mean,
        "acc_max": acc_mean*1.8,
        "acc_std": acc_mean*0.4,
        "wind_mean": wind_speed_local,
        "wind_max": wind_speed_local,
        "wind_std": 0.0,
        "headwind_mean": head,
        "crosswind_mean": cross,
        "headwind_std": 0.0,
        "crosswind_std": 0.0,
        "payload": float(PAYLOAD_FIXED) if "PAYLOAD_FIXED" in globals() else 0.0,
    }

    P_hat = float(model.predict(make_X_edge(feats))[0])
    return (P_hat * dt), heading_xy, P_hat, dt, d

# ---- Path xyz ----
path_xyz = np.vstack([idx_to_xyz(i) for i in path_idx])

# ---- Evaluate + logs ----
total = 0.0
prev_h = None

seg_Phat = []
seg_cost = []
seg_dt = []
seg_dist = []
cum_cost = [0.0]
cum_dist = [0.0]

for i in range(len(path_xyz)-1):
    pu = path_xyz[i]
    pv = path_xyz[i+1]
    c, prev_h, Phat, dt, d = segment_power_cost(pu, pv, prev_h)

    total += c
    seg_Phat.append(Phat)
    seg_cost.append(c)
    seg_dt.append(dt)
    seg_dist.append(d)

    cum_cost.append(total)
    cum_dist.append(cum_dist[-1] + d)

print("AdaBoost-evaluated total cost (sum P_hat*dt):", total)

# ---- Plot 1: Segment power ----
plt.figure(figsize=(8,4))
plt.plot(seg_Phat, marker="o", markersize=2)
plt.title("Segment-wise Predicted Power (AdaBoost)")
plt.xlabel("Segment index")
plt.ylabel("Predicted Power (W)")
plt.grid(True)
plt.show()

# ---- Plot 2: Segment cost ----
plt.figure(figsize=(8,4))
plt.plot(seg_cost, marker="o", markersize=2)
plt.title("Segment-wise Cost (P_hat * dt)")
plt.xlabel("Segment index")
plt.ylabel("Cost (W·s)")
plt.grid(True)
plt.show()

# ---- Plot 3: Cumulative cost vs distance ----
plt.figure(figsize=(8,4))
plt.plot(cum_dist, cum_cost, marker="o", markersize=2)
plt.title("Cumulative Path Cost (sum P_hat * dt)")
plt.xlabel("Cumulative Distance (m)")
plt.ylabel("Cumulative Cost (W·s)")
plt.grid(True)
plt.show()